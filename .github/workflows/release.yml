on:
  workflow_dispatch:
    inputs:
      version:
        description: 'Version bump type'
        required: true
        type: choice
        options:
          - patch  # 1.0.0 -> 1.0.1
          - minor  # 1.0.0 -> 1.1.0
          - major  # 1.0.0 -> 2.0.0

permissions:
  contents: write

concurrency:
  group: release
  cancel-in-progress: true

jobs:
  release:
    runs-on: ubuntu-latest

    steps:
      - name: Checkout repository
        uses: actions/checkout@v4
        with:
          fetch-depth: 0
          token: ${{ secrets.GITHUB_TOKEN }}

      - name: Verify branch
        run: |
          CURRENT_BRANCH=$(git rev-parse --abbrev-ref HEAD)
          if [ "$CURRENT_BRANCH" != "main" ]; then
            echo "::error::Releases must be created from main branch (current: $CURRENT_BRANCH)"
            exit 1
          fi
          echo "✓ Running on main branch"

      - name: Validate repository state
        run: |
          # Check for uncommitted changes
          if ! git diff-index --quiet HEAD --; then
            echo "::error::Repository has uncommitted changes"
            git status
            exit 1
          fi

          # Check if current version is already tagged
          CURRENT_VERSION="v$(jq -r '.version' package.json)"
          if git rev-parse "$CURRENT_VERSION" >/dev/null 2>&1; then
            echo "::error::Current version $CURRENT_VERSION is already tagged"
            exit 1
          fi

          # Check if we're behind origin/main
          git fetch origin main
          BEHIND_COUNT=$(git rev-list HEAD..origin/main --count)
          if [ "$BEHIND_COUNT" -gt 0 ]; then
            echo "::error::Local branch is $BEHIND_COUNT commits behind origin/main"
            echo "::error::Pull latest changes first: git pull origin main"
            exit 1
          fi

          echo "✓ Repository state is valid"

      - name: Setup Bun
        uses: oven-sh/setup-bun@v2
        with:
          bun-version: latest

      - name: Setup Node.js (for npm version)
        uses: actions/setup-node@v4
        with:
          node-version: '20'

      - name: Configure Git
        run: |
          git config user.name "github-actions[bot]"
          git config user.email "github-actions[bot]@users.noreply.github.com"

      - name: Install dependencies
        run: bun install --frozen-lockfile

      - name: Run full build check
        run: bun run check

      - name: Bump version
        id: version
        run: |
          NEW_VERSION=$(npm version ${{ inputs.version }} --no-git-tag-version)
          echo "new_version=$NEW_VERSION" >> $GITHUB_OUTPUT
          echo "Version bumped to: $NEW_VERSION"

      - name: Generate CHANGELOG from commits
        run: |
          VERSION="${{ steps.version.outputs.new_version }}"
          VERSION_NUM="${VERSION#v}"
          DATE=$(date +%Y-%m-%d)

          # Validate CHANGELOG.md structure
          if ! grep -q "^## \[Unreleased\]" CHANGELOG.md; then
            echo "::error::CHANGELOG.md missing [Unreleased] section"
            exit 1
          fi

          # Get the last version tag
          LAST_TAG=$(git describe --tags --abbrev=0 2>/dev/null || echo "")

          if [ -z "$LAST_TAG" ]; then
            echo "No previous tags found, using all commits"
            COMMIT_RANGE="HEAD"
          else
            COMMIT_RANGE="$LAST_TAG..HEAD"
          fi

          # Parse conventional commits and generate changelog sections
          echo "## [$VERSION_NUM] - $DATE" > /tmp/new_version.txt
          echo "" >> /tmp/new_version.txt

          # Extract commits by type
          ADDED=$(git log $COMMIT_RANGE --pretty=format:"%s" --no-merges | grep -E "^feat(\(.+\))?:" | sed 's/^feat[^:]*: /- /' || true)
          CHANGED=$(git log $COMMIT_RANGE --pretty=format:"%s" --no-merges | grep -E "^(refactor|perf|style)(\(.+\))?:" | sed 's/^[^:]*: /- /' || true)
          FIXED=$(git log $COMMIT_RANGE --pretty=format:"%s" --no-merges | grep -E "^fix(\(.+\))?:" | sed 's/^fix[^:]*: /- /' || true)
          DOCS=$(git log $COMMIT_RANGE --pretty=format:"%s" --no-merges | grep -E "^docs(\(.+\))?:" | sed 's/^docs[^:]*: /- /' || true)
          BREAKING=$(git log $COMMIT_RANGE --pretty=format:"%B" --no-merges | grep -E "BREAKING CHANGE:" | sed 's/BREAKING CHANGE: /- /' || true)

          # Add sections only if they have content
          if [ -n "$ADDED" ]; then
            echo "### Added" >> /tmp/new_version.txt
            echo "" >> /tmp/new_version.txt
            echo "$ADDED" >> /tmp/new_version.txt
            echo "" >> /tmp/new_version.txt
          fi

          if [ -n "$CHANGED" ]; then
            echo "### Changed" >> /tmp/new_version.txt
            echo "" >> /tmp/new_version.txt
            echo "$CHANGED" >> /tmp/new_version.txt
            echo "" >> /tmp/new_version.txt
          fi

          if [ -n "$FIXED" ]; then
            echo "### Fixed" >> /tmp/new_version.txt
            echo "" >> /tmp/new_version.txt
            echo "$FIXED" >> /tmp/new_version.txt
            echo "" >> /tmp/new_version.txt
          fi

          if [ -n "$DOCS" ]; then
            echo "### Documentation" >> /tmp/new_version.txt
            echo "" >> /tmp/new_version.txt
            echo "$DOCS" >> /tmp/new_version.txt
            echo "" >> /tmp/new_version.txt
          fi

          if [ -n "$BREAKING" ]; then
            echo "### BREAKING CHANGES" >> /tmp/new_version.txt
            echo "" >> /tmp/new_version.txt
            echo "$BREAKING" >> /tmp/new_version.txt
            echo "" >> /tmp/new_version.txt
          fi

          # If no conventional commits found, add a note
          if [ -z "$ADDED" ] && [ -z "$CHANGED" ] && [ -z "$FIXED" ] && [ -z "$DOCS" ]; then
            echo "### Changed" >> /tmp/new_version.txt
            echo "" >> /tmp/new_version.txt
            echo "- Internal improvements and maintenance" >> /tmp/new_version.txt
            echo "" >> /tmp/new_version.txt
          fi

          # Insert new version entry after [Unreleased] section
          awk '
            BEGIN { found_unreleased = 0; inserted = 0 }
            /^## \[Unreleased\]/ { found_unreleased = 1; print; next }
            found_unreleased && !inserted && /^## \[/ {
              while ((getline line < "/tmp/new_version.txt") > 0) {
                print line
              }
              close("/tmp/new_version.txt")
              inserted = 1
            }
            { print }
          ' CHANGELOG.md > CHANGELOG.tmp

          # Verify insertion succeeded
          if ! grep -q "## \[$VERSION_NUM\]" CHANGELOG.tmp; then
            echo "::error::Failed to insert version $VERSION_NUM into CHANGELOG.md"
            rm -f CHANGELOG.tmp /tmp/new_version.txt
            exit 1
          fi

          mv CHANGELOG.tmp CHANGELOG.md
          rm -f /tmp/new_version.txt

          echo "CHANGELOG.md auto-generated from conventional commits"
          echo ""
          echo "Generated changelog for $VERSION_NUM:"
          git log $COMMIT_RANGE --pretty=format:"- %s" --no-merges | head -20

      - name: Commit and tag changes
        run: |
          git add package.json CHANGELOG.md
          git commit -m "chore(release): ${{ steps.version.outputs.new_version }}"
          git tag ${{ steps.version.outputs.new_version }}

          # Push both commit and tag atomically to prevent race conditions
          git push origin main --follow-tags

          echo "✓ Commit and tag ${{ steps.version.outputs.new_version }} pushed"

      - name: Verify tag on remote
        run: |
          if ! git ls-remote --tags origin | grep -q "${{ steps.version.outputs.new_version }}"; then
            echo "::error::Tag ${{ steps.version.outputs.new_version }} not found on remote"
            exit 1
          fi
          echo "✓ Tag ${{ steps.version.outputs.new_version }} verified on remote"

      - name: Summary
        run: |
          echo "## Release Created" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "- **Version**: ${{ steps.version.outputs.new_version }}" >> $GITHUB_STEP_SUMMARY
          echo "- **Type**: ${{ inputs.version }} version bump" >> $GITHUB_STEP_SUMMARY
          echo "- **Changelog**: Auto-generated from conventional commits" >> $GITHUB_STEP_SUMMARY
          echo "- **Status**: Tag pushed, publish workflow will trigger automatically" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "### Next Steps" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "1. Monitor the [publish workflow](https://github.com/${{ github.repository }}/actions/workflows/publish.yml)" >> $GITHUB_STEP_SUMMARY
          echo "2. Verify package on [npm](https://www.npmjs.com/package/bun-osv-scanner/v/${{ steps.version.outputs.new_version }})" >> $GITHUB_STEP_SUMMARY
          echo "3. Check the [GitHub Release](https://github.com/${{ github.repository }}/releases/tag/${{ steps.version.outputs.new_version }})" >> $GITHUB_STEP_SUMMARY
